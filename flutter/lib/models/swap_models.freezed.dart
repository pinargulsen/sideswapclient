// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'swap_models.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$SwapPriceSubscribeState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function() send,
    required TResult Function() recv,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? send,
    TResult Function()? recv,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? send,
    TResult Function()? recv,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SwapPriceSubscribeStateEmpty value) empty,
    required TResult Function(SwapPriceSubscribeStateSend value) send,
    required TResult Function(SwapPriceSubscribeStateRecv value) recv,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(SwapPriceSubscribeStateEmpty value)? empty,
    TResult Function(SwapPriceSubscribeStateSend value)? send,
    TResult Function(SwapPriceSubscribeStateRecv value)? recv,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SwapPriceSubscribeStateEmpty value)? empty,
    TResult Function(SwapPriceSubscribeStateSend value)? send,
    TResult Function(SwapPriceSubscribeStateRecv value)? recv,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SwapPriceSubscribeStateCopyWith<$Res> {
  factory $SwapPriceSubscribeStateCopyWith(SwapPriceSubscribeState value,
          $Res Function(SwapPriceSubscribeState) then) =
      _$SwapPriceSubscribeStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$SwapPriceSubscribeStateCopyWithImpl<$Res>
    implements $SwapPriceSubscribeStateCopyWith<$Res> {
  _$SwapPriceSubscribeStateCopyWithImpl(this._value, this._then);

  final SwapPriceSubscribeState _value;
  // ignore: unused_field
  final $Res Function(SwapPriceSubscribeState) _then;
}

/// @nodoc
abstract class _$$SwapPriceSubscribeStateEmptyCopyWith<$Res> {
  factory _$$SwapPriceSubscribeStateEmptyCopyWith(
          _$SwapPriceSubscribeStateEmpty value,
          $Res Function(_$SwapPriceSubscribeStateEmpty) then) =
      __$$SwapPriceSubscribeStateEmptyCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SwapPriceSubscribeStateEmptyCopyWithImpl<$Res>
    extends _$SwapPriceSubscribeStateCopyWithImpl<$Res>
    implements _$$SwapPriceSubscribeStateEmptyCopyWith<$Res> {
  __$$SwapPriceSubscribeStateEmptyCopyWithImpl(
      _$SwapPriceSubscribeStateEmpty _value,
      $Res Function(_$SwapPriceSubscribeStateEmpty) _then)
      : super(_value, (v) => _then(v as _$SwapPriceSubscribeStateEmpty));

  @override
  _$SwapPriceSubscribeStateEmpty get _value =>
      super._value as _$SwapPriceSubscribeStateEmpty;
}

/// @nodoc

class _$SwapPriceSubscribeStateEmpty implements SwapPriceSubscribeStateEmpty {
  const _$SwapPriceSubscribeStateEmpty();

  @override
  String toString() {
    return 'SwapPriceSubscribeState.empty()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SwapPriceSubscribeStateEmpty);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function() send,
    required TResult Function() recv,
  }) {
    return empty();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? send,
    TResult Function()? recv,
  }) {
    return empty?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? send,
    TResult Function()? recv,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SwapPriceSubscribeStateEmpty value) empty,
    required TResult Function(SwapPriceSubscribeStateSend value) send,
    required TResult Function(SwapPriceSubscribeStateRecv value) recv,
  }) {
    return empty(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(SwapPriceSubscribeStateEmpty value)? empty,
    TResult Function(SwapPriceSubscribeStateSend value)? send,
    TResult Function(SwapPriceSubscribeStateRecv value)? recv,
  }) {
    return empty?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SwapPriceSubscribeStateEmpty value)? empty,
    TResult Function(SwapPriceSubscribeStateSend value)? send,
    TResult Function(SwapPriceSubscribeStateRecv value)? recv,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty(this);
    }
    return orElse();
  }
}

abstract class SwapPriceSubscribeStateEmpty implements SwapPriceSubscribeState {
  const factory SwapPriceSubscribeStateEmpty() = _$SwapPriceSubscribeStateEmpty;
}

/// @nodoc
abstract class _$$SwapPriceSubscribeStateSendCopyWith<$Res> {
  factory _$$SwapPriceSubscribeStateSendCopyWith(
          _$SwapPriceSubscribeStateSend value,
          $Res Function(_$SwapPriceSubscribeStateSend) then) =
      __$$SwapPriceSubscribeStateSendCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SwapPriceSubscribeStateSendCopyWithImpl<$Res>
    extends _$SwapPriceSubscribeStateCopyWithImpl<$Res>
    implements _$$SwapPriceSubscribeStateSendCopyWith<$Res> {
  __$$SwapPriceSubscribeStateSendCopyWithImpl(
      _$SwapPriceSubscribeStateSend _value,
      $Res Function(_$SwapPriceSubscribeStateSend) _then)
      : super(_value, (v) => _then(v as _$SwapPriceSubscribeStateSend));

  @override
  _$SwapPriceSubscribeStateSend get _value =>
      super._value as _$SwapPriceSubscribeStateSend;
}

/// @nodoc

class _$SwapPriceSubscribeStateSend implements SwapPriceSubscribeStateSend {
  const _$SwapPriceSubscribeStateSend();

  @override
  String toString() {
    return 'SwapPriceSubscribeState.send()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SwapPriceSubscribeStateSend);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function() send,
    required TResult Function() recv,
  }) {
    return send();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? send,
    TResult Function()? recv,
  }) {
    return send?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? send,
    TResult Function()? recv,
    required TResult orElse(),
  }) {
    if (send != null) {
      return send();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SwapPriceSubscribeStateEmpty value) empty,
    required TResult Function(SwapPriceSubscribeStateSend value) send,
    required TResult Function(SwapPriceSubscribeStateRecv value) recv,
  }) {
    return send(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(SwapPriceSubscribeStateEmpty value)? empty,
    TResult Function(SwapPriceSubscribeStateSend value)? send,
    TResult Function(SwapPriceSubscribeStateRecv value)? recv,
  }) {
    return send?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SwapPriceSubscribeStateEmpty value)? empty,
    TResult Function(SwapPriceSubscribeStateSend value)? send,
    TResult Function(SwapPriceSubscribeStateRecv value)? recv,
    required TResult orElse(),
  }) {
    if (send != null) {
      return send(this);
    }
    return orElse();
  }
}

abstract class SwapPriceSubscribeStateSend implements SwapPriceSubscribeState {
  const factory SwapPriceSubscribeStateSend() = _$SwapPriceSubscribeStateSend;
}

/// @nodoc
abstract class _$$SwapPriceSubscribeStateRecvCopyWith<$Res> {
  factory _$$SwapPriceSubscribeStateRecvCopyWith(
          _$SwapPriceSubscribeStateRecv value,
          $Res Function(_$SwapPriceSubscribeStateRecv) then) =
      __$$SwapPriceSubscribeStateRecvCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SwapPriceSubscribeStateRecvCopyWithImpl<$Res>
    extends _$SwapPriceSubscribeStateCopyWithImpl<$Res>
    implements _$$SwapPriceSubscribeStateRecvCopyWith<$Res> {
  __$$SwapPriceSubscribeStateRecvCopyWithImpl(
      _$SwapPriceSubscribeStateRecv _value,
      $Res Function(_$SwapPriceSubscribeStateRecv) _then)
      : super(_value, (v) => _then(v as _$SwapPriceSubscribeStateRecv));

  @override
  _$SwapPriceSubscribeStateRecv get _value =>
      super._value as _$SwapPriceSubscribeStateRecv;
}

/// @nodoc

class _$SwapPriceSubscribeStateRecv implements SwapPriceSubscribeStateRecv {
  const _$SwapPriceSubscribeStateRecv();

  @override
  String toString() {
    return 'SwapPriceSubscribeState.recv()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SwapPriceSubscribeStateRecv);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function() send,
    required TResult Function() recv,
  }) {
    return recv();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? send,
    TResult Function()? recv,
  }) {
    return recv?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? send,
    TResult Function()? recv,
    required TResult orElse(),
  }) {
    if (recv != null) {
      return recv();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SwapPriceSubscribeStateEmpty value) empty,
    required TResult Function(SwapPriceSubscribeStateSend value) send,
    required TResult Function(SwapPriceSubscribeStateRecv value) recv,
  }) {
    return recv(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(SwapPriceSubscribeStateEmpty value)? empty,
    TResult Function(SwapPriceSubscribeStateSend value)? send,
    TResult Function(SwapPriceSubscribeStateRecv value)? recv,
  }) {
    return recv?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SwapPriceSubscribeStateEmpty value)? empty,
    TResult Function(SwapPriceSubscribeStateSend value)? send,
    TResult Function(SwapPriceSubscribeStateRecv value)? recv,
    required TResult orElse(),
  }) {
    if (recv != null) {
      return recv(this);
    }
    return orElse();
  }
}

abstract class SwapPriceSubscribeStateRecv implements SwapPriceSubscribeState {
  const factory SwapPriceSubscribeStateRecv() = _$SwapPriceSubscribeStateRecv;
}

/// @nodoc
mixin _$SwapCurrentFeeRate {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(FeeRate feeRate) data,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(FeeRate feeRate)? data,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(FeeRate feeRate)? data,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SwapCurrentFeeRateEmpty value) empty,
    required TResult Function(SwapCurrentFeeRateData value) data,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(SwapCurrentFeeRateEmpty value)? empty,
    TResult Function(SwapCurrentFeeRateData value)? data,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SwapCurrentFeeRateEmpty value)? empty,
    TResult Function(SwapCurrentFeeRateData value)? data,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SwapCurrentFeeRateCopyWith<$Res> {
  factory $SwapCurrentFeeRateCopyWith(
          SwapCurrentFeeRate value, $Res Function(SwapCurrentFeeRate) then) =
      _$SwapCurrentFeeRateCopyWithImpl<$Res>;
}

/// @nodoc
class _$SwapCurrentFeeRateCopyWithImpl<$Res>
    implements $SwapCurrentFeeRateCopyWith<$Res> {
  _$SwapCurrentFeeRateCopyWithImpl(this._value, this._then);

  final SwapCurrentFeeRate _value;
  // ignore: unused_field
  final $Res Function(SwapCurrentFeeRate) _then;
}

/// @nodoc
abstract class _$$SwapCurrentFeeRateEmptyCopyWith<$Res> {
  factory _$$SwapCurrentFeeRateEmptyCopyWith(_$SwapCurrentFeeRateEmpty value,
          $Res Function(_$SwapCurrentFeeRateEmpty) then) =
      __$$SwapCurrentFeeRateEmptyCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SwapCurrentFeeRateEmptyCopyWithImpl<$Res>
    extends _$SwapCurrentFeeRateCopyWithImpl<$Res>
    implements _$$SwapCurrentFeeRateEmptyCopyWith<$Res> {
  __$$SwapCurrentFeeRateEmptyCopyWithImpl(_$SwapCurrentFeeRateEmpty _value,
      $Res Function(_$SwapCurrentFeeRateEmpty) _then)
      : super(_value, (v) => _then(v as _$SwapCurrentFeeRateEmpty));

  @override
  _$SwapCurrentFeeRateEmpty get _value =>
      super._value as _$SwapCurrentFeeRateEmpty;
}

/// @nodoc

class _$SwapCurrentFeeRateEmpty implements SwapCurrentFeeRateEmpty {
  const _$SwapCurrentFeeRateEmpty();

  @override
  String toString() {
    return 'SwapCurrentFeeRate.empty()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SwapCurrentFeeRateEmpty);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(FeeRate feeRate) data,
  }) {
    return empty();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(FeeRate feeRate)? data,
  }) {
    return empty?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(FeeRate feeRate)? data,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SwapCurrentFeeRateEmpty value) empty,
    required TResult Function(SwapCurrentFeeRateData value) data,
  }) {
    return empty(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(SwapCurrentFeeRateEmpty value)? empty,
    TResult Function(SwapCurrentFeeRateData value)? data,
  }) {
    return empty?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SwapCurrentFeeRateEmpty value)? empty,
    TResult Function(SwapCurrentFeeRateData value)? data,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty(this);
    }
    return orElse();
  }
}

abstract class SwapCurrentFeeRateEmpty implements SwapCurrentFeeRate {
  const factory SwapCurrentFeeRateEmpty() = _$SwapCurrentFeeRateEmpty;
}

/// @nodoc
abstract class _$$SwapCurrentFeeRateDataCopyWith<$Res> {
  factory _$$SwapCurrentFeeRateDataCopyWith(_$SwapCurrentFeeRateData value,
          $Res Function(_$SwapCurrentFeeRateData) then) =
      __$$SwapCurrentFeeRateDataCopyWithImpl<$Res>;
  $Res call({FeeRate feeRate});
}

/// @nodoc
class __$$SwapCurrentFeeRateDataCopyWithImpl<$Res>
    extends _$SwapCurrentFeeRateCopyWithImpl<$Res>
    implements _$$SwapCurrentFeeRateDataCopyWith<$Res> {
  __$$SwapCurrentFeeRateDataCopyWithImpl(_$SwapCurrentFeeRateData _value,
      $Res Function(_$SwapCurrentFeeRateData) _then)
      : super(_value, (v) => _then(v as _$SwapCurrentFeeRateData));

  @override
  _$SwapCurrentFeeRateData get _value =>
      super._value as _$SwapCurrentFeeRateData;

  @override
  $Res call({
    Object? feeRate = freezed,
  }) {
    return _then(_$SwapCurrentFeeRateData(
      feeRate: feeRate == freezed
          ? _value.feeRate
          : feeRate // ignore: cast_nullable_to_non_nullable
              as FeeRate,
    ));
  }
}

/// @nodoc

class _$SwapCurrentFeeRateData implements SwapCurrentFeeRateData {
  const _$SwapCurrentFeeRateData({required this.feeRate});

  @override
  final FeeRate feeRate;

  @override
  String toString() {
    return 'SwapCurrentFeeRate.data(feeRate: $feeRate)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SwapCurrentFeeRateData &&
            const DeepCollectionEquality().equals(other.feeRate, feeRate));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(feeRate));

  @JsonKey(ignore: true)
  @override
  _$$SwapCurrentFeeRateDataCopyWith<_$SwapCurrentFeeRateData> get copyWith =>
      __$$SwapCurrentFeeRateDataCopyWithImpl<_$SwapCurrentFeeRateData>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(FeeRate feeRate) data,
  }) {
    return data(feeRate);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(FeeRate feeRate)? data,
  }) {
    return data?.call(feeRate);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(FeeRate feeRate)? data,
    required TResult orElse(),
  }) {
    if (data != null) {
      return data(feeRate);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SwapCurrentFeeRateEmpty value) empty,
    required TResult Function(SwapCurrentFeeRateData value) data,
  }) {
    return data(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(SwapCurrentFeeRateEmpty value)? empty,
    TResult Function(SwapCurrentFeeRateData value)? data,
  }) {
    return data?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SwapCurrentFeeRateEmpty value)? empty,
    TResult Function(SwapCurrentFeeRateData value)? data,
    required TResult orElse(),
  }) {
    if (data != null) {
      return data(this);
    }
    return orElse();
  }
}

abstract class SwapCurrentFeeRateData implements SwapCurrentFeeRate {
  const factory SwapCurrentFeeRateData({required final FeeRate feeRate}) =
      _$SwapCurrentFeeRateData;

  FeeRate get feeRate => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$$SwapCurrentFeeRateDataCopyWith<_$SwapCurrentFeeRateData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$SwapRecvAmountPriceStream {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(String value) data,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(String value)? data,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(String value)? data,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SwapRecvAmountPriceStreamEmpty value) empty,
    required TResult Function(SwapRecvAmountPriceStreamData value) data,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(SwapRecvAmountPriceStreamEmpty value)? empty,
    TResult Function(SwapRecvAmountPriceStreamData value)? data,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SwapRecvAmountPriceStreamEmpty value)? empty,
    TResult Function(SwapRecvAmountPriceStreamData value)? data,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SwapRecvAmountPriceStreamCopyWith<$Res> {
  factory $SwapRecvAmountPriceStreamCopyWith(SwapRecvAmountPriceStream value,
          $Res Function(SwapRecvAmountPriceStream) then) =
      _$SwapRecvAmountPriceStreamCopyWithImpl<$Res>;
}

/// @nodoc
class _$SwapRecvAmountPriceStreamCopyWithImpl<$Res>
    implements $SwapRecvAmountPriceStreamCopyWith<$Res> {
  _$SwapRecvAmountPriceStreamCopyWithImpl(this._value, this._then);

  final SwapRecvAmountPriceStream _value;
  // ignore: unused_field
  final $Res Function(SwapRecvAmountPriceStream) _then;
}

/// @nodoc
abstract class _$$SwapRecvAmountPriceStreamEmptyCopyWith<$Res> {
  factory _$$SwapRecvAmountPriceStreamEmptyCopyWith(
          _$SwapRecvAmountPriceStreamEmpty value,
          $Res Function(_$SwapRecvAmountPriceStreamEmpty) then) =
      __$$SwapRecvAmountPriceStreamEmptyCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SwapRecvAmountPriceStreamEmptyCopyWithImpl<$Res>
    extends _$SwapRecvAmountPriceStreamCopyWithImpl<$Res>
    implements _$$SwapRecvAmountPriceStreamEmptyCopyWith<$Res> {
  __$$SwapRecvAmountPriceStreamEmptyCopyWithImpl(
      _$SwapRecvAmountPriceStreamEmpty _value,
      $Res Function(_$SwapRecvAmountPriceStreamEmpty) _then)
      : super(_value, (v) => _then(v as _$SwapRecvAmountPriceStreamEmpty));

  @override
  _$SwapRecvAmountPriceStreamEmpty get _value =>
      super._value as _$SwapRecvAmountPriceStreamEmpty;
}

/// @nodoc

class _$SwapRecvAmountPriceStreamEmpty
    implements SwapRecvAmountPriceStreamEmpty {
  const _$SwapRecvAmountPriceStreamEmpty();

  @override
  String toString() {
    return 'SwapRecvAmountPriceStream.empty()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SwapRecvAmountPriceStreamEmpty);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(String value) data,
  }) {
    return empty();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(String value)? data,
  }) {
    return empty?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(String value)? data,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SwapRecvAmountPriceStreamEmpty value) empty,
    required TResult Function(SwapRecvAmountPriceStreamData value) data,
  }) {
    return empty(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(SwapRecvAmountPriceStreamEmpty value)? empty,
    TResult Function(SwapRecvAmountPriceStreamData value)? data,
  }) {
    return empty?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SwapRecvAmountPriceStreamEmpty value)? empty,
    TResult Function(SwapRecvAmountPriceStreamData value)? data,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty(this);
    }
    return orElse();
  }
}

abstract class SwapRecvAmountPriceStreamEmpty
    implements SwapRecvAmountPriceStream {
  const factory SwapRecvAmountPriceStreamEmpty() =
      _$SwapRecvAmountPriceStreamEmpty;
}

/// @nodoc
abstract class _$$SwapRecvAmountPriceStreamDataCopyWith<$Res> {
  factory _$$SwapRecvAmountPriceStreamDataCopyWith(
          _$SwapRecvAmountPriceStreamData value,
          $Res Function(_$SwapRecvAmountPriceStreamData) then) =
      __$$SwapRecvAmountPriceStreamDataCopyWithImpl<$Res>;
  $Res call({String value});
}

/// @nodoc
class __$$SwapRecvAmountPriceStreamDataCopyWithImpl<$Res>
    extends _$SwapRecvAmountPriceStreamCopyWithImpl<$Res>
    implements _$$SwapRecvAmountPriceStreamDataCopyWith<$Res> {
  __$$SwapRecvAmountPriceStreamDataCopyWithImpl(
      _$SwapRecvAmountPriceStreamData _value,
      $Res Function(_$SwapRecvAmountPriceStreamData) _then)
      : super(_value, (v) => _then(v as _$SwapRecvAmountPriceStreamData));

  @override
  _$SwapRecvAmountPriceStreamData get _value =>
      super._value as _$SwapRecvAmountPriceStreamData;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_$SwapRecvAmountPriceStreamData(
      value: value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$SwapRecvAmountPriceStreamData implements SwapRecvAmountPriceStreamData {
  const _$SwapRecvAmountPriceStreamData({required this.value});

  @override
  final String value;

  @override
  String toString() {
    return 'SwapRecvAmountPriceStream.data(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SwapRecvAmountPriceStreamData &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @JsonKey(ignore: true)
  @override
  _$$SwapRecvAmountPriceStreamDataCopyWith<_$SwapRecvAmountPriceStreamData>
      get copyWith => __$$SwapRecvAmountPriceStreamDataCopyWithImpl<
          _$SwapRecvAmountPriceStreamData>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(String value) data,
  }) {
    return data(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(String value)? data,
  }) {
    return data?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(String value)? data,
    required TResult orElse(),
  }) {
    if (data != null) {
      return data(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SwapRecvAmountPriceStreamEmpty value) empty,
    required TResult Function(SwapRecvAmountPriceStreamData value) data,
  }) {
    return data(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(SwapRecvAmountPriceStreamEmpty value)? empty,
    TResult Function(SwapRecvAmountPriceStreamData value)? data,
  }) {
    return data?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SwapRecvAmountPriceStreamEmpty value)? empty,
    TResult Function(SwapRecvAmountPriceStreamData value)? data,
    required TResult orElse(),
  }) {
    if (data != null) {
      return data(this);
    }
    return orElse();
  }
}

abstract class SwapRecvAmountPriceStreamData
    implements SwapRecvAmountPriceStream {
  const factory SwapRecvAmountPriceStreamData({required final String value}) =
      _$SwapRecvAmountPriceStreamData;

  String get value => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$$SwapRecvAmountPriceStreamDataCopyWith<_$SwapRecvAmountPriceStreamData>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$SwapSendAmountPriceStream {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(String value) data,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(String value)? data,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(String value)? data,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SwapSendAmountPriceStreamEmpty value) empty,
    required TResult Function(SwapSendAmountPriceStreamData value) data,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(SwapSendAmountPriceStreamEmpty value)? empty,
    TResult Function(SwapSendAmountPriceStreamData value)? data,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SwapSendAmountPriceStreamEmpty value)? empty,
    TResult Function(SwapSendAmountPriceStreamData value)? data,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SwapSendAmountPriceStreamCopyWith<$Res> {
  factory $SwapSendAmountPriceStreamCopyWith(SwapSendAmountPriceStream value,
          $Res Function(SwapSendAmountPriceStream) then) =
      _$SwapSendAmountPriceStreamCopyWithImpl<$Res>;
}

/// @nodoc
class _$SwapSendAmountPriceStreamCopyWithImpl<$Res>
    implements $SwapSendAmountPriceStreamCopyWith<$Res> {
  _$SwapSendAmountPriceStreamCopyWithImpl(this._value, this._then);

  final SwapSendAmountPriceStream _value;
  // ignore: unused_field
  final $Res Function(SwapSendAmountPriceStream) _then;
}

/// @nodoc
abstract class _$$SwapSendAmountPriceStreamEmptyCopyWith<$Res> {
  factory _$$SwapSendAmountPriceStreamEmptyCopyWith(
          _$SwapSendAmountPriceStreamEmpty value,
          $Res Function(_$SwapSendAmountPriceStreamEmpty) then) =
      __$$SwapSendAmountPriceStreamEmptyCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SwapSendAmountPriceStreamEmptyCopyWithImpl<$Res>
    extends _$SwapSendAmountPriceStreamCopyWithImpl<$Res>
    implements _$$SwapSendAmountPriceStreamEmptyCopyWith<$Res> {
  __$$SwapSendAmountPriceStreamEmptyCopyWithImpl(
      _$SwapSendAmountPriceStreamEmpty _value,
      $Res Function(_$SwapSendAmountPriceStreamEmpty) _then)
      : super(_value, (v) => _then(v as _$SwapSendAmountPriceStreamEmpty));

  @override
  _$SwapSendAmountPriceStreamEmpty get _value =>
      super._value as _$SwapSendAmountPriceStreamEmpty;
}

/// @nodoc

class _$SwapSendAmountPriceStreamEmpty
    implements SwapSendAmountPriceStreamEmpty {
  const _$SwapSendAmountPriceStreamEmpty();

  @override
  String toString() {
    return 'SwapSendAmountPriceStream.empty()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SwapSendAmountPriceStreamEmpty);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(String value) data,
  }) {
    return empty();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(String value)? data,
  }) {
    return empty?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(String value)? data,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SwapSendAmountPriceStreamEmpty value) empty,
    required TResult Function(SwapSendAmountPriceStreamData value) data,
  }) {
    return empty(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(SwapSendAmountPriceStreamEmpty value)? empty,
    TResult Function(SwapSendAmountPriceStreamData value)? data,
  }) {
    return empty?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SwapSendAmountPriceStreamEmpty value)? empty,
    TResult Function(SwapSendAmountPriceStreamData value)? data,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty(this);
    }
    return orElse();
  }
}

abstract class SwapSendAmountPriceStreamEmpty
    implements SwapSendAmountPriceStream {
  const factory SwapSendAmountPriceStreamEmpty() =
      _$SwapSendAmountPriceStreamEmpty;
}

/// @nodoc
abstract class _$$SwapSendAmountPriceStreamDataCopyWith<$Res> {
  factory _$$SwapSendAmountPriceStreamDataCopyWith(
          _$SwapSendAmountPriceStreamData value,
          $Res Function(_$SwapSendAmountPriceStreamData) then) =
      __$$SwapSendAmountPriceStreamDataCopyWithImpl<$Res>;
  $Res call({String value});
}

/// @nodoc
class __$$SwapSendAmountPriceStreamDataCopyWithImpl<$Res>
    extends _$SwapSendAmountPriceStreamCopyWithImpl<$Res>
    implements _$$SwapSendAmountPriceStreamDataCopyWith<$Res> {
  __$$SwapSendAmountPriceStreamDataCopyWithImpl(
      _$SwapSendAmountPriceStreamData _value,
      $Res Function(_$SwapSendAmountPriceStreamData) _then)
      : super(_value, (v) => _then(v as _$SwapSendAmountPriceStreamData));

  @override
  _$SwapSendAmountPriceStreamData get _value =>
      super._value as _$SwapSendAmountPriceStreamData;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_$SwapSendAmountPriceStreamData(
      value: value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$SwapSendAmountPriceStreamData implements SwapSendAmountPriceStreamData {
  const _$SwapSendAmountPriceStreamData({required this.value});

  @override
  final String value;

  @override
  String toString() {
    return 'SwapSendAmountPriceStream.data(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SwapSendAmountPriceStreamData &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @JsonKey(ignore: true)
  @override
  _$$SwapSendAmountPriceStreamDataCopyWith<_$SwapSendAmountPriceStreamData>
      get copyWith => __$$SwapSendAmountPriceStreamDataCopyWithImpl<
          _$SwapSendAmountPriceStreamData>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(String value) data,
  }) {
    return data(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(String value)? data,
  }) {
    return data?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(String value)? data,
    required TResult orElse(),
  }) {
    if (data != null) {
      return data(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SwapSendAmountPriceStreamEmpty value) empty,
    required TResult Function(SwapSendAmountPriceStreamData value) data,
  }) {
    return data(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(SwapSendAmountPriceStreamEmpty value)? empty,
    TResult Function(SwapSendAmountPriceStreamData value)? data,
  }) {
    return data?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SwapSendAmountPriceStreamEmpty value)? empty,
    TResult Function(SwapSendAmountPriceStreamData value)? data,
    required TResult orElse(),
  }) {
    if (data != null) {
      return data(this);
    }
    return orElse();
  }
}

abstract class SwapSendAmountPriceStreamData
    implements SwapSendAmountPriceStream {
  const factory SwapSendAmountPriceStreamData({required final String value}) =
      _$SwapSendAmountPriceStreamData;

  String get value => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$$SwapSendAmountPriceStreamDataCopyWith<_$SwapSendAmountPriceStreamData>
      get copyWith => throw _privateConstructorUsedError;
}
