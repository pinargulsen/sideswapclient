// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'pegx_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$PegxLoginState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function() loginDialog,
    required TResult Function(String requestId) login,
    required TResult Function() logged,
    required TResult Function() gaidWaiting,
    required TResult Function() gaidAdded,
    required TResult Function() gaidError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function()? loginDialog,
    TResult? Function(String requestId)? login,
    TResult? Function()? logged,
    TResult? Function()? gaidWaiting,
    TResult? Function()? gaidAdded,
    TResult? Function()? gaidError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function()? loginDialog,
    TResult Function(String requestId)? login,
    TResult Function()? logged,
    TResult Function()? gaidWaiting,
    TResult Function()? gaidAdded,
    TResult Function()? gaidError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PegxLoginStateLoading value) loading,
    required TResult Function(PegxLoginStateLoginDialog value) loginDialog,
    required TResult Function(PegxLoginStateLogin value) login,
    required TResult Function(PegxLoginStateLogged value) logged,
    required TResult Function(PegxLoginStateGaidWaiting value) gaidWaiting,
    required TResult Function(PegxLoginStateGaidAdded value) gaidAdded,
    required TResult Function(PegxLoginStateGaidError value) gaidError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PegxLoginStateLoading value)? loading,
    TResult? Function(PegxLoginStateLoginDialog value)? loginDialog,
    TResult? Function(PegxLoginStateLogin value)? login,
    TResult? Function(PegxLoginStateLogged value)? logged,
    TResult? Function(PegxLoginStateGaidWaiting value)? gaidWaiting,
    TResult? Function(PegxLoginStateGaidAdded value)? gaidAdded,
    TResult? Function(PegxLoginStateGaidError value)? gaidError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PegxLoginStateLoading value)? loading,
    TResult Function(PegxLoginStateLoginDialog value)? loginDialog,
    TResult Function(PegxLoginStateLogin value)? login,
    TResult Function(PegxLoginStateLogged value)? logged,
    TResult Function(PegxLoginStateGaidWaiting value)? gaidWaiting,
    TResult Function(PegxLoginStateGaidAdded value)? gaidAdded,
    TResult Function(PegxLoginStateGaidError value)? gaidError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PegxLoginStateCopyWith<$Res> {
  factory $PegxLoginStateCopyWith(
          PegxLoginState value, $Res Function(PegxLoginState) then) =
      _$PegxLoginStateCopyWithImpl<$Res, PegxLoginState>;
}

/// @nodoc
class _$PegxLoginStateCopyWithImpl<$Res, $Val extends PegxLoginState>
    implements $PegxLoginStateCopyWith<$Res> {
  _$PegxLoginStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$PegxLoginStateLoadingCopyWith<$Res> {
  factory _$$PegxLoginStateLoadingCopyWith(_$PegxLoginStateLoading value,
          $Res Function(_$PegxLoginStateLoading) then) =
      __$$PegxLoginStateLoadingCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PegxLoginStateLoadingCopyWithImpl<$Res>
    extends _$PegxLoginStateCopyWithImpl<$Res, _$PegxLoginStateLoading>
    implements _$$PegxLoginStateLoadingCopyWith<$Res> {
  __$$PegxLoginStateLoadingCopyWithImpl(_$PegxLoginStateLoading _value,
      $Res Function(_$PegxLoginStateLoading) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PegxLoginStateLoading implements PegxLoginStateLoading {
  const _$PegxLoginStateLoading();

  @override
  String toString() {
    return 'PegxLoginState.loading()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PegxLoginStateLoading);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function() loginDialog,
    required TResult Function(String requestId) login,
    required TResult Function() logged,
    required TResult Function() gaidWaiting,
    required TResult Function() gaidAdded,
    required TResult Function() gaidError,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function()? loginDialog,
    TResult? Function(String requestId)? login,
    TResult? Function()? logged,
    TResult? Function()? gaidWaiting,
    TResult? Function()? gaidAdded,
    TResult? Function()? gaidError,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function()? loginDialog,
    TResult Function(String requestId)? login,
    TResult Function()? logged,
    TResult Function()? gaidWaiting,
    TResult Function()? gaidAdded,
    TResult Function()? gaidError,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PegxLoginStateLoading value) loading,
    required TResult Function(PegxLoginStateLoginDialog value) loginDialog,
    required TResult Function(PegxLoginStateLogin value) login,
    required TResult Function(PegxLoginStateLogged value) logged,
    required TResult Function(PegxLoginStateGaidWaiting value) gaidWaiting,
    required TResult Function(PegxLoginStateGaidAdded value) gaidAdded,
    required TResult Function(PegxLoginStateGaidError value) gaidError,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PegxLoginStateLoading value)? loading,
    TResult? Function(PegxLoginStateLoginDialog value)? loginDialog,
    TResult? Function(PegxLoginStateLogin value)? login,
    TResult? Function(PegxLoginStateLogged value)? logged,
    TResult? Function(PegxLoginStateGaidWaiting value)? gaidWaiting,
    TResult? Function(PegxLoginStateGaidAdded value)? gaidAdded,
    TResult? Function(PegxLoginStateGaidError value)? gaidError,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PegxLoginStateLoading value)? loading,
    TResult Function(PegxLoginStateLoginDialog value)? loginDialog,
    TResult Function(PegxLoginStateLogin value)? login,
    TResult Function(PegxLoginStateLogged value)? logged,
    TResult Function(PegxLoginStateGaidWaiting value)? gaidWaiting,
    TResult Function(PegxLoginStateGaidAdded value)? gaidAdded,
    TResult Function(PegxLoginStateGaidError value)? gaidError,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class PegxLoginStateLoading implements PegxLoginState {
  const factory PegxLoginStateLoading() = _$PegxLoginStateLoading;
}

/// @nodoc
abstract class _$$PegxLoginStateLoginDialogCopyWith<$Res> {
  factory _$$PegxLoginStateLoginDialogCopyWith(
          _$PegxLoginStateLoginDialog value,
          $Res Function(_$PegxLoginStateLoginDialog) then) =
      __$$PegxLoginStateLoginDialogCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PegxLoginStateLoginDialogCopyWithImpl<$Res>
    extends _$PegxLoginStateCopyWithImpl<$Res, _$PegxLoginStateLoginDialog>
    implements _$$PegxLoginStateLoginDialogCopyWith<$Res> {
  __$$PegxLoginStateLoginDialogCopyWithImpl(_$PegxLoginStateLoginDialog _value,
      $Res Function(_$PegxLoginStateLoginDialog) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PegxLoginStateLoginDialog implements PegxLoginStateLoginDialog {
  const _$PegxLoginStateLoginDialog();

  @override
  String toString() {
    return 'PegxLoginState.loginDialog()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PegxLoginStateLoginDialog);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function() loginDialog,
    required TResult Function(String requestId) login,
    required TResult Function() logged,
    required TResult Function() gaidWaiting,
    required TResult Function() gaidAdded,
    required TResult Function() gaidError,
  }) {
    return loginDialog();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function()? loginDialog,
    TResult? Function(String requestId)? login,
    TResult? Function()? logged,
    TResult? Function()? gaidWaiting,
    TResult? Function()? gaidAdded,
    TResult? Function()? gaidError,
  }) {
    return loginDialog?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function()? loginDialog,
    TResult Function(String requestId)? login,
    TResult Function()? logged,
    TResult Function()? gaidWaiting,
    TResult Function()? gaidAdded,
    TResult Function()? gaidError,
    required TResult orElse(),
  }) {
    if (loginDialog != null) {
      return loginDialog();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PegxLoginStateLoading value) loading,
    required TResult Function(PegxLoginStateLoginDialog value) loginDialog,
    required TResult Function(PegxLoginStateLogin value) login,
    required TResult Function(PegxLoginStateLogged value) logged,
    required TResult Function(PegxLoginStateGaidWaiting value) gaidWaiting,
    required TResult Function(PegxLoginStateGaidAdded value) gaidAdded,
    required TResult Function(PegxLoginStateGaidError value) gaidError,
  }) {
    return loginDialog(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PegxLoginStateLoading value)? loading,
    TResult? Function(PegxLoginStateLoginDialog value)? loginDialog,
    TResult? Function(PegxLoginStateLogin value)? login,
    TResult? Function(PegxLoginStateLogged value)? logged,
    TResult? Function(PegxLoginStateGaidWaiting value)? gaidWaiting,
    TResult? Function(PegxLoginStateGaidAdded value)? gaidAdded,
    TResult? Function(PegxLoginStateGaidError value)? gaidError,
  }) {
    return loginDialog?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PegxLoginStateLoading value)? loading,
    TResult Function(PegxLoginStateLoginDialog value)? loginDialog,
    TResult Function(PegxLoginStateLogin value)? login,
    TResult Function(PegxLoginStateLogged value)? logged,
    TResult Function(PegxLoginStateGaidWaiting value)? gaidWaiting,
    TResult Function(PegxLoginStateGaidAdded value)? gaidAdded,
    TResult Function(PegxLoginStateGaidError value)? gaidError,
    required TResult orElse(),
  }) {
    if (loginDialog != null) {
      return loginDialog(this);
    }
    return orElse();
  }
}

abstract class PegxLoginStateLoginDialog implements PegxLoginState {
  const factory PegxLoginStateLoginDialog() = _$PegxLoginStateLoginDialog;
}

/// @nodoc
abstract class _$$PegxLoginStateLoginCopyWith<$Res> {
  factory _$$PegxLoginStateLoginCopyWith(_$PegxLoginStateLogin value,
          $Res Function(_$PegxLoginStateLogin) then) =
      __$$PegxLoginStateLoginCopyWithImpl<$Res>;
  @useResult
  $Res call({String requestId});
}

/// @nodoc
class __$$PegxLoginStateLoginCopyWithImpl<$Res>
    extends _$PegxLoginStateCopyWithImpl<$Res, _$PegxLoginStateLogin>
    implements _$$PegxLoginStateLoginCopyWith<$Res> {
  __$$PegxLoginStateLoginCopyWithImpl(
      _$PegxLoginStateLogin _value, $Res Function(_$PegxLoginStateLogin) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? requestId = null,
  }) {
    return _then(_$PegxLoginStateLogin(
      requestId: null == requestId
          ? _value.requestId
          : requestId // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$PegxLoginStateLogin implements PegxLoginStateLogin {
  const _$PegxLoginStateLogin({required this.requestId});

  @override
  final String requestId;

  @override
  String toString() {
    return 'PegxLoginState.login(requestId: $requestId)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PegxLoginStateLogin &&
            (identical(other.requestId, requestId) ||
                other.requestId == requestId));
  }

  @override
  int get hashCode => Object.hash(runtimeType, requestId);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PegxLoginStateLoginCopyWith<_$PegxLoginStateLogin> get copyWith =>
      __$$PegxLoginStateLoginCopyWithImpl<_$PegxLoginStateLogin>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function() loginDialog,
    required TResult Function(String requestId) login,
    required TResult Function() logged,
    required TResult Function() gaidWaiting,
    required TResult Function() gaidAdded,
    required TResult Function() gaidError,
  }) {
    return login(requestId);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function()? loginDialog,
    TResult? Function(String requestId)? login,
    TResult? Function()? logged,
    TResult? Function()? gaidWaiting,
    TResult? Function()? gaidAdded,
    TResult? Function()? gaidError,
  }) {
    return login?.call(requestId);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function()? loginDialog,
    TResult Function(String requestId)? login,
    TResult Function()? logged,
    TResult Function()? gaidWaiting,
    TResult Function()? gaidAdded,
    TResult Function()? gaidError,
    required TResult orElse(),
  }) {
    if (login != null) {
      return login(requestId);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PegxLoginStateLoading value) loading,
    required TResult Function(PegxLoginStateLoginDialog value) loginDialog,
    required TResult Function(PegxLoginStateLogin value) login,
    required TResult Function(PegxLoginStateLogged value) logged,
    required TResult Function(PegxLoginStateGaidWaiting value) gaidWaiting,
    required TResult Function(PegxLoginStateGaidAdded value) gaidAdded,
    required TResult Function(PegxLoginStateGaidError value) gaidError,
  }) {
    return login(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PegxLoginStateLoading value)? loading,
    TResult? Function(PegxLoginStateLoginDialog value)? loginDialog,
    TResult? Function(PegxLoginStateLogin value)? login,
    TResult? Function(PegxLoginStateLogged value)? logged,
    TResult? Function(PegxLoginStateGaidWaiting value)? gaidWaiting,
    TResult? Function(PegxLoginStateGaidAdded value)? gaidAdded,
    TResult? Function(PegxLoginStateGaidError value)? gaidError,
  }) {
    return login?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PegxLoginStateLoading value)? loading,
    TResult Function(PegxLoginStateLoginDialog value)? loginDialog,
    TResult Function(PegxLoginStateLogin value)? login,
    TResult Function(PegxLoginStateLogged value)? logged,
    TResult Function(PegxLoginStateGaidWaiting value)? gaidWaiting,
    TResult Function(PegxLoginStateGaidAdded value)? gaidAdded,
    TResult Function(PegxLoginStateGaidError value)? gaidError,
    required TResult orElse(),
  }) {
    if (login != null) {
      return login(this);
    }
    return orElse();
  }
}

abstract class PegxLoginStateLogin implements PegxLoginState {
  const factory PegxLoginStateLogin({required final String requestId}) =
      _$PegxLoginStateLogin;

  String get requestId;
  @JsonKey(ignore: true)
  _$$PegxLoginStateLoginCopyWith<_$PegxLoginStateLogin> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PegxLoginStateLoggedCopyWith<$Res> {
  factory _$$PegxLoginStateLoggedCopyWith(_$PegxLoginStateLogged value,
          $Res Function(_$PegxLoginStateLogged) then) =
      __$$PegxLoginStateLoggedCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PegxLoginStateLoggedCopyWithImpl<$Res>
    extends _$PegxLoginStateCopyWithImpl<$Res, _$PegxLoginStateLogged>
    implements _$$PegxLoginStateLoggedCopyWith<$Res> {
  __$$PegxLoginStateLoggedCopyWithImpl(_$PegxLoginStateLogged _value,
      $Res Function(_$PegxLoginStateLogged) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PegxLoginStateLogged implements PegxLoginStateLogged {
  const _$PegxLoginStateLogged();

  @override
  String toString() {
    return 'PegxLoginState.logged()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PegxLoginStateLogged);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function() loginDialog,
    required TResult Function(String requestId) login,
    required TResult Function() logged,
    required TResult Function() gaidWaiting,
    required TResult Function() gaidAdded,
    required TResult Function() gaidError,
  }) {
    return logged();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function()? loginDialog,
    TResult? Function(String requestId)? login,
    TResult? Function()? logged,
    TResult? Function()? gaidWaiting,
    TResult? Function()? gaidAdded,
    TResult? Function()? gaidError,
  }) {
    return logged?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function()? loginDialog,
    TResult Function(String requestId)? login,
    TResult Function()? logged,
    TResult Function()? gaidWaiting,
    TResult Function()? gaidAdded,
    TResult Function()? gaidError,
    required TResult orElse(),
  }) {
    if (logged != null) {
      return logged();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PegxLoginStateLoading value) loading,
    required TResult Function(PegxLoginStateLoginDialog value) loginDialog,
    required TResult Function(PegxLoginStateLogin value) login,
    required TResult Function(PegxLoginStateLogged value) logged,
    required TResult Function(PegxLoginStateGaidWaiting value) gaidWaiting,
    required TResult Function(PegxLoginStateGaidAdded value) gaidAdded,
    required TResult Function(PegxLoginStateGaidError value) gaidError,
  }) {
    return logged(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PegxLoginStateLoading value)? loading,
    TResult? Function(PegxLoginStateLoginDialog value)? loginDialog,
    TResult? Function(PegxLoginStateLogin value)? login,
    TResult? Function(PegxLoginStateLogged value)? logged,
    TResult? Function(PegxLoginStateGaidWaiting value)? gaidWaiting,
    TResult? Function(PegxLoginStateGaidAdded value)? gaidAdded,
    TResult? Function(PegxLoginStateGaidError value)? gaidError,
  }) {
    return logged?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PegxLoginStateLoading value)? loading,
    TResult Function(PegxLoginStateLoginDialog value)? loginDialog,
    TResult Function(PegxLoginStateLogin value)? login,
    TResult Function(PegxLoginStateLogged value)? logged,
    TResult Function(PegxLoginStateGaidWaiting value)? gaidWaiting,
    TResult Function(PegxLoginStateGaidAdded value)? gaidAdded,
    TResult Function(PegxLoginStateGaidError value)? gaidError,
    required TResult orElse(),
  }) {
    if (logged != null) {
      return logged(this);
    }
    return orElse();
  }
}

abstract class PegxLoginStateLogged implements PegxLoginState {
  const factory PegxLoginStateLogged() = _$PegxLoginStateLogged;
}

/// @nodoc
abstract class _$$PegxLoginStateGaidWaitingCopyWith<$Res> {
  factory _$$PegxLoginStateGaidWaitingCopyWith(
          _$PegxLoginStateGaidWaiting value,
          $Res Function(_$PegxLoginStateGaidWaiting) then) =
      __$$PegxLoginStateGaidWaitingCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PegxLoginStateGaidWaitingCopyWithImpl<$Res>
    extends _$PegxLoginStateCopyWithImpl<$Res, _$PegxLoginStateGaidWaiting>
    implements _$$PegxLoginStateGaidWaitingCopyWith<$Res> {
  __$$PegxLoginStateGaidWaitingCopyWithImpl(_$PegxLoginStateGaidWaiting _value,
      $Res Function(_$PegxLoginStateGaidWaiting) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PegxLoginStateGaidWaiting implements PegxLoginStateGaidWaiting {
  const _$PegxLoginStateGaidWaiting();

  @override
  String toString() {
    return 'PegxLoginState.gaidWaiting()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PegxLoginStateGaidWaiting);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function() loginDialog,
    required TResult Function(String requestId) login,
    required TResult Function() logged,
    required TResult Function() gaidWaiting,
    required TResult Function() gaidAdded,
    required TResult Function() gaidError,
  }) {
    return gaidWaiting();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function()? loginDialog,
    TResult? Function(String requestId)? login,
    TResult? Function()? logged,
    TResult? Function()? gaidWaiting,
    TResult? Function()? gaidAdded,
    TResult? Function()? gaidError,
  }) {
    return gaidWaiting?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function()? loginDialog,
    TResult Function(String requestId)? login,
    TResult Function()? logged,
    TResult Function()? gaidWaiting,
    TResult Function()? gaidAdded,
    TResult Function()? gaidError,
    required TResult orElse(),
  }) {
    if (gaidWaiting != null) {
      return gaidWaiting();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PegxLoginStateLoading value) loading,
    required TResult Function(PegxLoginStateLoginDialog value) loginDialog,
    required TResult Function(PegxLoginStateLogin value) login,
    required TResult Function(PegxLoginStateLogged value) logged,
    required TResult Function(PegxLoginStateGaidWaiting value) gaidWaiting,
    required TResult Function(PegxLoginStateGaidAdded value) gaidAdded,
    required TResult Function(PegxLoginStateGaidError value) gaidError,
  }) {
    return gaidWaiting(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PegxLoginStateLoading value)? loading,
    TResult? Function(PegxLoginStateLoginDialog value)? loginDialog,
    TResult? Function(PegxLoginStateLogin value)? login,
    TResult? Function(PegxLoginStateLogged value)? logged,
    TResult? Function(PegxLoginStateGaidWaiting value)? gaidWaiting,
    TResult? Function(PegxLoginStateGaidAdded value)? gaidAdded,
    TResult? Function(PegxLoginStateGaidError value)? gaidError,
  }) {
    return gaidWaiting?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PegxLoginStateLoading value)? loading,
    TResult Function(PegxLoginStateLoginDialog value)? loginDialog,
    TResult Function(PegxLoginStateLogin value)? login,
    TResult Function(PegxLoginStateLogged value)? logged,
    TResult Function(PegxLoginStateGaidWaiting value)? gaidWaiting,
    TResult Function(PegxLoginStateGaidAdded value)? gaidAdded,
    TResult Function(PegxLoginStateGaidError value)? gaidError,
    required TResult orElse(),
  }) {
    if (gaidWaiting != null) {
      return gaidWaiting(this);
    }
    return orElse();
  }
}

abstract class PegxLoginStateGaidWaiting implements PegxLoginState {
  const factory PegxLoginStateGaidWaiting() = _$PegxLoginStateGaidWaiting;
}

/// @nodoc
abstract class _$$PegxLoginStateGaidAddedCopyWith<$Res> {
  factory _$$PegxLoginStateGaidAddedCopyWith(_$PegxLoginStateGaidAdded value,
          $Res Function(_$PegxLoginStateGaidAdded) then) =
      __$$PegxLoginStateGaidAddedCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PegxLoginStateGaidAddedCopyWithImpl<$Res>
    extends _$PegxLoginStateCopyWithImpl<$Res, _$PegxLoginStateGaidAdded>
    implements _$$PegxLoginStateGaidAddedCopyWith<$Res> {
  __$$PegxLoginStateGaidAddedCopyWithImpl(_$PegxLoginStateGaidAdded _value,
      $Res Function(_$PegxLoginStateGaidAdded) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PegxLoginStateGaidAdded implements PegxLoginStateGaidAdded {
  const _$PegxLoginStateGaidAdded();

  @override
  String toString() {
    return 'PegxLoginState.gaidAdded()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PegxLoginStateGaidAdded);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function() loginDialog,
    required TResult Function(String requestId) login,
    required TResult Function() logged,
    required TResult Function() gaidWaiting,
    required TResult Function() gaidAdded,
    required TResult Function() gaidError,
  }) {
    return gaidAdded();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function()? loginDialog,
    TResult? Function(String requestId)? login,
    TResult? Function()? logged,
    TResult? Function()? gaidWaiting,
    TResult? Function()? gaidAdded,
    TResult? Function()? gaidError,
  }) {
    return gaidAdded?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function()? loginDialog,
    TResult Function(String requestId)? login,
    TResult Function()? logged,
    TResult Function()? gaidWaiting,
    TResult Function()? gaidAdded,
    TResult Function()? gaidError,
    required TResult orElse(),
  }) {
    if (gaidAdded != null) {
      return gaidAdded();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PegxLoginStateLoading value) loading,
    required TResult Function(PegxLoginStateLoginDialog value) loginDialog,
    required TResult Function(PegxLoginStateLogin value) login,
    required TResult Function(PegxLoginStateLogged value) logged,
    required TResult Function(PegxLoginStateGaidWaiting value) gaidWaiting,
    required TResult Function(PegxLoginStateGaidAdded value) gaidAdded,
    required TResult Function(PegxLoginStateGaidError value) gaidError,
  }) {
    return gaidAdded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PegxLoginStateLoading value)? loading,
    TResult? Function(PegxLoginStateLoginDialog value)? loginDialog,
    TResult? Function(PegxLoginStateLogin value)? login,
    TResult? Function(PegxLoginStateLogged value)? logged,
    TResult? Function(PegxLoginStateGaidWaiting value)? gaidWaiting,
    TResult? Function(PegxLoginStateGaidAdded value)? gaidAdded,
    TResult? Function(PegxLoginStateGaidError value)? gaidError,
  }) {
    return gaidAdded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PegxLoginStateLoading value)? loading,
    TResult Function(PegxLoginStateLoginDialog value)? loginDialog,
    TResult Function(PegxLoginStateLogin value)? login,
    TResult Function(PegxLoginStateLogged value)? logged,
    TResult Function(PegxLoginStateGaidWaiting value)? gaidWaiting,
    TResult Function(PegxLoginStateGaidAdded value)? gaidAdded,
    TResult Function(PegxLoginStateGaidError value)? gaidError,
    required TResult orElse(),
  }) {
    if (gaidAdded != null) {
      return gaidAdded(this);
    }
    return orElse();
  }
}

abstract class PegxLoginStateGaidAdded implements PegxLoginState {
  const factory PegxLoginStateGaidAdded() = _$PegxLoginStateGaidAdded;
}

/// @nodoc
abstract class _$$PegxLoginStateGaidErrorCopyWith<$Res> {
  factory _$$PegxLoginStateGaidErrorCopyWith(_$PegxLoginStateGaidError value,
          $Res Function(_$PegxLoginStateGaidError) then) =
      __$$PegxLoginStateGaidErrorCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PegxLoginStateGaidErrorCopyWithImpl<$Res>
    extends _$PegxLoginStateCopyWithImpl<$Res, _$PegxLoginStateGaidError>
    implements _$$PegxLoginStateGaidErrorCopyWith<$Res> {
  __$$PegxLoginStateGaidErrorCopyWithImpl(_$PegxLoginStateGaidError _value,
      $Res Function(_$PegxLoginStateGaidError) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PegxLoginStateGaidError implements PegxLoginStateGaidError {
  const _$PegxLoginStateGaidError();

  @override
  String toString() {
    return 'PegxLoginState.gaidError()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PegxLoginStateGaidError);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function() loginDialog,
    required TResult Function(String requestId) login,
    required TResult Function() logged,
    required TResult Function() gaidWaiting,
    required TResult Function() gaidAdded,
    required TResult Function() gaidError,
  }) {
    return gaidError();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function()? loginDialog,
    TResult? Function(String requestId)? login,
    TResult? Function()? logged,
    TResult? Function()? gaidWaiting,
    TResult? Function()? gaidAdded,
    TResult? Function()? gaidError,
  }) {
    return gaidError?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function()? loginDialog,
    TResult Function(String requestId)? login,
    TResult Function()? logged,
    TResult Function()? gaidWaiting,
    TResult Function()? gaidAdded,
    TResult Function()? gaidError,
    required TResult orElse(),
  }) {
    if (gaidError != null) {
      return gaidError();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PegxLoginStateLoading value) loading,
    required TResult Function(PegxLoginStateLoginDialog value) loginDialog,
    required TResult Function(PegxLoginStateLogin value) login,
    required TResult Function(PegxLoginStateLogged value) logged,
    required TResult Function(PegxLoginStateGaidWaiting value) gaidWaiting,
    required TResult Function(PegxLoginStateGaidAdded value) gaidAdded,
    required TResult Function(PegxLoginStateGaidError value) gaidError,
  }) {
    return gaidError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PegxLoginStateLoading value)? loading,
    TResult? Function(PegxLoginStateLoginDialog value)? loginDialog,
    TResult? Function(PegxLoginStateLogin value)? login,
    TResult? Function(PegxLoginStateLogged value)? logged,
    TResult? Function(PegxLoginStateGaidWaiting value)? gaidWaiting,
    TResult? Function(PegxLoginStateGaidAdded value)? gaidAdded,
    TResult? Function(PegxLoginStateGaidError value)? gaidError,
  }) {
    return gaidError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PegxLoginStateLoading value)? loading,
    TResult Function(PegxLoginStateLoginDialog value)? loginDialog,
    TResult Function(PegxLoginStateLogin value)? login,
    TResult Function(PegxLoginStateLogged value)? logged,
    TResult Function(PegxLoginStateGaidWaiting value)? gaidWaiting,
    TResult Function(PegxLoginStateGaidAdded value)? gaidAdded,
    TResult Function(PegxLoginStateGaidError value)? gaidError,
    required TResult orElse(),
  }) {
    if (gaidError != null) {
      return gaidError(this);
    }
    return orElse();
  }
}

abstract class PegxLoginStateGaidError implements PegxLoginState {
  const factory PegxLoginStateGaidError() = _$PegxLoginStateGaidError;
}

/// @nodoc
mixin _$PegxGaidState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function() loading,
    required TResult Function() registered,
    required TResult Function() unregistered,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function()? loading,
    TResult? Function()? registered,
    TResult? Function()? unregistered,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? loading,
    TResult Function()? registered,
    TResult Function()? unregistered,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PegxGaidStateEmpty value) empty,
    required TResult Function(PegxGaidStateLoading value) loading,
    required TResult Function(PegxGaidStateRegistered value) registered,
    required TResult Function(PegxGaidStateUnregistered value) unregistered,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PegxGaidStateEmpty value)? empty,
    TResult? Function(PegxGaidStateLoading value)? loading,
    TResult? Function(PegxGaidStateRegistered value)? registered,
    TResult? Function(PegxGaidStateUnregistered value)? unregistered,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PegxGaidStateEmpty value)? empty,
    TResult Function(PegxGaidStateLoading value)? loading,
    TResult Function(PegxGaidStateRegistered value)? registered,
    TResult Function(PegxGaidStateUnregistered value)? unregistered,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PegxGaidStateCopyWith<$Res> {
  factory $PegxGaidStateCopyWith(
          PegxGaidState value, $Res Function(PegxGaidState) then) =
      _$PegxGaidStateCopyWithImpl<$Res, PegxGaidState>;
}

/// @nodoc
class _$PegxGaidStateCopyWithImpl<$Res, $Val extends PegxGaidState>
    implements $PegxGaidStateCopyWith<$Res> {
  _$PegxGaidStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$PegxGaidStateEmptyCopyWith<$Res> {
  factory _$$PegxGaidStateEmptyCopyWith(_$PegxGaidStateEmpty value,
          $Res Function(_$PegxGaidStateEmpty) then) =
      __$$PegxGaidStateEmptyCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PegxGaidStateEmptyCopyWithImpl<$Res>
    extends _$PegxGaidStateCopyWithImpl<$Res, _$PegxGaidStateEmpty>
    implements _$$PegxGaidStateEmptyCopyWith<$Res> {
  __$$PegxGaidStateEmptyCopyWithImpl(
      _$PegxGaidStateEmpty _value, $Res Function(_$PegxGaidStateEmpty) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PegxGaidStateEmpty implements PegxGaidStateEmpty {
  const _$PegxGaidStateEmpty();

  @override
  String toString() {
    return 'PegxGaidState.empty()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PegxGaidStateEmpty);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function() loading,
    required TResult Function() registered,
    required TResult Function() unregistered,
  }) {
    return empty();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function()? loading,
    TResult? Function()? registered,
    TResult? Function()? unregistered,
  }) {
    return empty?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? loading,
    TResult Function()? registered,
    TResult Function()? unregistered,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PegxGaidStateEmpty value) empty,
    required TResult Function(PegxGaidStateLoading value) loading,
    required TResult Function(PegxGaidStateRegistered value) registered,
    required TResult Function(PegxGaidStateUnregistered value) unregistered,
  }) {
    return empty(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PegxGaidStateEmpty value)? empty,
    TResult? Function(PegxGaidStateLoading value)? loading,
    TResult? Function(PegxGaidStateRegistered value)? registered,
    TResult? Function(PegxGaidStateUnregistered value)? unregistered,
  }) {
    return empty?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PegxGaidStateEmpty value)? empty,
    TResult Function(PegxGaidStateLoading value)? loading,
    TResult Function(PegxGaidStateRegistered value)? registered,
    TResult Function(PegxGaidStateUnregistered value)? unregistered,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty(this);
    }
    return orElse();
  }
}

abstract class PegxGaidStateEmpty implements PegxGaidState {
  const factory PegxGaidStateEmpty() = _$PegxGaidStateEmpty;
}

/// @nodoc
abstract class _$$PegxGaidStateLoadingCopyWith<$Res> {
  factory _$$PegxGaidStateLoadingCopyWith(_$PegxGaidStateLoading value,
          $Res Function(_$PegxGaidStateLoading) then) =
      __$$PegxGaidStateLoadingCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PegxGaidStateLoadingCopyWithImpl<$Res>
    extends _$PegxGaidStateCopyWithImpl<$Res, _$PegxGaidStateLoading>
    implements _$$PegxGaidStateLoadingCopyWith<$Res> {
  __$$PegxGaidStateLoadingCopyWithImpl(_$PegxGaidStateLoading _value,
      $Res Function(_$PegxGaidStateLoading) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PegxGaidStateLoading implements PegxGaidStateLoading {
  const _$PegxGaidStateLoading();

  @override
  String toString() {
    return 'PegxGaidState.loading()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PegxGaidStateLoading);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function() loading,
    required TResult Function() registered,
    required TResult Function() unregistered,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function()? loading,
    TResult? Function()? registered,
    TResult? Function()? unregistered,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? loading,
    TResult Function()? registered,
    TResult Function()? unregistered,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PegxGaidStateEmpty value) empty,
    required TResult Function(PegxGaidStateLoading value) loading,
    required TResult Function(PegxGaidStateRegistered value) registered,
    required TResult Function(PegxGaidStateUnregistered value) unregistered,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PegxGaidStateEmpty value)? empty,
    TResult? Function(PegxGaidStateLoading value)? loading,
    TResult? Function(PegxGaidStateRegistered value)? registered,
    TResult? Function(PegxGaidStateUnregistered value)? unregistered,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PegxGaidStateEmpty value)? empty,
    TResult Function(PegxGaidStateLoading value)? loading,
    TResult Function(PegxGaidStateRegistered value)? registered,
    TResult Function(PegxGaidStateUnregistered value)? unregistered,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class PegxGaidStateLoading implements PegxGaidState {
  const factory PegxGaidStateLoading() = _$PegxGaidStateLoading;
}

/// @nodoc
abstract class _$$PegxGaidStateRegisteredCopyWith<$Res> {
  factory _$$PegxGaidStateRegisteredCopyWith(_$PegxGaidStateRegistered value,
          $Res Function(_$PegxGaidStateRegistered) then) =
      __$$PegxGaidStateRegisteredCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PegxGaidStateRegisteredCopyWithImpl<$Res>
    extends _$PegxGaidStateCopyWithImpl<$Res, _$PegxGaidStateRegistered>
    implements _$$PegxGaidStateRegisteredCopyWith<$Res> {
  __$$PegxGaidStateRegisteredCopyWithImpl(_$PegxGaidStateRegistered _value,
      $Res Function(_$PegxGaidStateRegistered) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PegxGaidStateRegistered implements PegxGaidStateRegistered {
  const _$PegxGaidStateRegistered();

  @override
  String toString() {
    return 'PegxGaidState.registered()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PegxGaidStateRegistered);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function() loading,
    required TResult Function() registered,
    required TResult Function() unregistered,
  }) {
    return registered();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function()? loading,
    TResult? Function()? registered,
    TResult? Function()? unregistered,
  }) {
    return registered?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? loading,
    TResult Function()? registered,
    TResult Function()? unregistered,
    required TResult orElse(),
  }) {
    if (registered != null) {
      return registered();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PegxGaidStateEmpty value) empty,
    required TResult Function(PegxGaidStateLoading value) loading,
    required TResult Function(PegxGaidStateRegistered value) registered,
    required TResult Function(PegxGaidStateUnregistered value) unregistered,
  }) {
    return registered(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PegxGaidStateEmpty value)? empty,
    TResult? Function(PegxGaidStateLoading value)? loading,
    TResult? Function(PegxGaidStateRegistered value)? registered,
    TResult? Function(PegxGaidStateUnregistered value)? unregistered,
  }) {
    return registered?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PegxGaidStateEmpty value)? empty,
    TResult Function(PegxGaidStateLoading value)? loading,
    TResult Function(PegxGaidStateRegistered value)? registered,
    TResult Function(PegxGaidStateUnregistered value)? unregistered,
    required TResult orElse(),
  }) {
    if (registered != null) {
      return registered(this);
    }
    return orElse();
  }
}

abstract class PegxGaidStateRegistered implements PegxGaidState {
  const factory PegxGaidStateRegistered() = _$PegxGaidStateRegistered;
}

/// @nodoc
abstract class _$$PegxGaidStateUnregisteredCopyWith<$Res> {
  factory _$$PegxGaidStateUnregisteredCopyWith(
          _$PegxGaidStateUnregistered value,
          $Res Function(_$PegxGaidStateUnregistered) then) =
      __$$PegxGaidStateUnregisteredCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PegxGaidStateUnregisteredCopyWithImpl<$Res>
    extends _$PegxGaidStateCopyWithImpl<$Res, _$PegxGaidStateUnregistered>
    implements _$$PegxGaidStateUnregisteredCopyWith<$Res> {
  __$$PegxGaidStateUnregisteredCopyWithImpl(_$PegxGaidStateUnregistered _value,
      $Res Function(_$PegxGaidStateUnregistered) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PegxGaidStateUnregistered implements PegxGaidStateUnregistered {
  const _$PegxGaidStateUnregistered();

  @override
  String toString() {
    return 'PegxGaidState.unregistered()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PegxGaidStateUnregistered);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function() loading,
    required TResult Function() registered,
    required TResult Function() unregistered,
  }) {
    return unregistered();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function()? loading,
    TResult? Function()? registered,
    TResult? Function()? unregistered,
  }) {
    return unregistered?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? loading,
    TResult Function()? registered,
    TResult Function()? unregistered,
    required TResult orElse(),
  }) {
    if (unregistered != null) {
      return unregistered();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PegxGaidStateEmpty value) empty,
    required TResult Function(PegxGaidStateLoading value) loading,
    required TResult Function(PegxGaidStateRegistered value) registered,
    required TResult Function(PegxGaidStateUnregistered value) unregistered,
  }) {
    return unregistered(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PegxGaidStateEmpty value)? empty,
    TResult? Function(PegxGaidStateLoading value)? loading,
    TResult? Function(PegxGaidStateRegistered value)? registered,
    TResult? Function(PegxGaidStateUnregistered value)? unregistered,
  }) {
    return unregistered?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PegxGaidStateEmpty value)? empty,
    TResult Function(PegxGaidStateLoading value)? loading,
    TResult Function(PegxGaidStateRegistered value)? registered,
    TResult Function(PegxGaidStateUnregistered value)? unregistered,
    required TResult orElse(),
  }) {
    if (unregistered != null) {
      return unregistered(this);
    }
    return orElse();
  }
}

abstract class PegxGaidStateUnregistered implements PegxGaidState {
  const factory PegxGaidStateUnregistered() = _$PegxGaidStateUnregistered;
}
